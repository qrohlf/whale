#!/usr/bin/env ruby
require 'rubygems'
require 'net/ssh'
require 'net/scp'
require 'commander/import'
require './config.rb'
require 'timeout'

program :name, 'manatee'
program :version, '0.0.1'
program :description, 'network control system'


targets = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
totalframes = 72


command :run do |c|
  c.syntax = 'manatee run "[command --opts]"'
  c.summary = 'run a command on all machines'
  c.description = ''
  c.action do |args, options|
    cmd = args.first;
    ssh_all(targets) do |ssh, user, host|
      puts "#{user}@#{host}$ #{cmd}"
      puts ssh.exec!(cmd);
    end
  end
end

command :clean do |c|
  c.syntax = 'manatee clean'
  c.summary = 'clean the results dir'
  c.description = ''
  c.action do |args, options|
    puts `rm -f results/*`
  end
end

command :install do |c|
  c.syntax = 'manatee install --mkdir -n numberofmachines -f framelimit'
  c.summary = 'distributed rendering'
  c.description = ''
  c.action do |args, options|

    puts "packaging installer"
    `./package_installer.sh`
    
    puts "creating install directory"
    ssh_all(targets) do |ssh, user, host|
      ssh.exec!("mkdir #{INSTALL_LOCATION}")
      puts "success!"
    end

    puts "uploading installer"
    scp_all((targets), "./install.zip", "#{INSTALL_LOCATION}/install.zip");
    puts "\n"

    # compile files
    puts "compiling renderer"
    ssh_all(targets) do |ssh, user, host|
      puts "...connection established"
      ssh.exec!("cd #{INSTALL_LOCATION} && unzip -o install.zip")
      puts "...installer unzipped"
      ssh.exec!("mkdir #{INSTALL_LOCATION}/install/bin")
      puts "...bin directory created"
      ssh.exec!("cd #{INSTALL_LOCATION}/install/ && make lab2.1")
      puts "...lab2.1 compiled"
    end
  end
end

command :render do |c|
  c.syntax = 'manatee render'
  c.summary = 'distributed rendering'
  c.description = ''

  c.action do |args, options|
    puts "rendering files"
    threads = Array.new
    targets.each_with_index do |i, index| #todo: THREEEEAAAAAADS
      threads << Thread.new(i, index) do |i, index|
        puts "starting thread #{i}"
        startframe = (totalframes/targets.count+1)*index
        endframe = startframe+(totalframes/targets.count+1)
        endframe = totalframes if endframe > totalframes
        target = MACHINES[i];
        # sleep 10
        begin 
          Net::SSH.start(target[:host], target[:user], :password => target[:pass], :timeout => 3) do |ssh|
            print "beginning rendering of frames #{startframe} to #{endframe} on #{target[:host]}\n"
            ssh.exec!("Xvfb :30 -ac -screen 0 1024x768x24")
            
            (startframe..endframe).each do |j|
              puts "rendering frame #{j}"
              puts ssh.exec!("cd #{INSTALL_LOCATION}/install && DISPLAY=':30' bin/lab2.1 lab21-mov #{j}") # currently segfaulting for reasons unknown
              # now scp the file to localhost
              result = "#{INSTALL_LOCATION}/install/lab21-mov#{sprintf("%04d", j)}.xwd"
              puts "downloading #{result}... from #{target[:host]}"
              Timeout::timeout(15) do 
                Net::SCP.download!(target[:host], target[:user], result, "./results/", :ssh => { :password => target[:pass] })
              end
            end

          end
        rescue Timeout::Error
          puts "Connection timed out on #{target[:host]}"
        rescue Net::SCP::Error
          puts "SCP Error on #{target[:host]}"
        rescue Net::SSH::AuthenticationFailed
          puts "Authentication failed on #{target[:host]}"
        rescue IOError
          puts "SSH session closed by target"
        rescue Errno::ECONNREFUSED
          puts "SSH connection refused by target"
        end
      end
      #ssh.loop # wait for all frames in job to finish rendering & downloading
    end
    threads.each(&:join)
    puts "Rendering Complete"
  end
end


def ssh_all(machines, options = {})
  machines.each do |i| 
      target = MACHINES[i];
      puts "############ initiating SSH to #{target[:host]} ############"
      if target[:host] == SOURCE[:host]
        puts "Skipping #{target[:host]} (control server)"
        next
      end

      begin 
        Net::SSH.start(target[:host], target[:user], :password => target[:pass], :timeout => 3) do |ssh|
          yield ssh, target[:user], target[:host]
        end
      rescue Timeout::Error
        puts "Connection timed out on #{target[:host]}"
      rescue Net::SSH::AuthenticationFailed
        puts "Authentication failed on #{target[:host]}"
      rescue IOError
        puts "SSH session closed by target"
      rescue Errno::ECONNREFUSED
        puts "SSH connection refused by target"
      end
      puts "\n"
    end
  end

def scp_all(machines, file, dest)
  machines.each do |i| 
      target = MACHINES[i];
      puts "############ initiating SCP to #{target[:host]} ############"
      begin
        Net::SCP.upload!(target[:host], target[:user], file, dest, :ssh => { :password => target[:pass] })
        puts "SCP upload to #{target[:host]} successful"
      rescue Net::SCP::Error
        puts "SCP to #{target[:host]} unsuccessful"
      end
    end
  end

